### Go 1.22 之前：共享的循环变量陷阱

在 Go 1.21 及更早的版本中，`for` 循环语句中声明的循环变量，在每次迭代中都是**同一个**变量，只是其值在不断更新。当在循环体内创建的闭包引用了这个变量时，它捕获的是这个变量的**内存地址**，而非当前迭代的瞬时值。

这会导致一个非常经典且容易出错的场景，尤其是在使用 `go` 关键字启动协程时：

**经典陷阱示例 (Go 1.21 及更早版本):**

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	values := []string{"a", "b", "c"}

	for _, v := range values {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(v)
		}()
	}

	wg.Wait()
}
```

**在 Go 1.21 或更早版本中运行，常见的输出是：**

```
c
c
c
```

**原因分析：**
`go func()` 创建的三个协程内的闭包都引用了同一个变量 `v`。由于协程的启动和调度需要时间，当这些协程真正开始执行 `fmt.Println(v)` 时，外层的 `for` 循环很可能已经全部完成。此时，变量 `v` 的值已经被更新为切片 `values` 的最后一个元素——"c"。因此，所有协程最终打印出的都是 "c"。

**过去的解决方案：**
为了避免这个问题，开发者必须在循环体内创建一个临时变量，将当前迭代的值“拷贝”一份，让闭包捕获这个临时变量：

```go
// 解决方案 1: 创建临时变量
for _, v := range values {
    v := v // 或 value := v
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println(v) // 闭包捕获的是新创建的 v
    }()
}

// 解决方案 2: 通过参数传递
for _, v := range values {
    wg.Add(1)
    go func(val string) {
        defer wg.Done()
        fmt.Println(val)
    }(v) // 将 v 的当前值作为参数传递给闭包
}
```
这两种方法都能确保每个协程得到的是其对应迭代的正确值，从而输出 "a", "b", "c" (顺序不定)。

---

### Go 1.22 及之后：循环变量的变革

为了从根本上解决这个长期存在的“陷阱”，Go 团队在 Go 1.22 版本中改变了 `for` 循环的语义。

从 Go 1.22 开始，`for` 循环中声明的变量在**每次迭代时都会被重新创建**。换言之，每次迭代都有一个全新的、独立的循环变量实例。

**Go 1.22 中的行为：**
如果将前述的“陷阱”示例代码在 Go 1.22 环境下编译和运行（确保你的 `go.mod` 文件中 `go` 的版本为 `1.22` 或更高），其行为将符合直觉：

**运行结果 (Go 1.22 及更高版本):**

```
a
b
c
(顺序不定)
```

**原因分析：**
由于每次迭代的变量 `v` 都是一个全新的、独立的变量，闭包在创建时自然地捕获了当前迭代的那个 `v`。即使外层循环继续进行，也不会影响已经被捕获的变量的值。这使得代码更简洁，也消除了长久以来的一个主要错误源。

这个改动适用于所有形式的 `for` 循环，包括：
- `for i, v := range x`
- `for i := 0; i < n; i++`
- `for condition {}`

### 总结与对比

| 特性 | Go 1.21 及更早版本 | Go 1.22 及更高版本 |
| :--- | :--- | :--- |
| **循环变量** | 整个循环共享**同一个**变量实例，每次迭代更新其值。 | **每次迭代**都会创建一个**新的、独立的**变量实例。 |
| **闭包捕获** | 捕获的是变量的内存地址（引用）。 | 捕获的是当前迭代的那个独立变量的引用。 |
| **常见行为** | 在并发或延迟执行中，闭包通常会看到循环变量的**最终值**。 | 闭包会看到其创建时所在迭代的**正确值**。 |
| **编码实践** | 必须手动创建临时变量或通过函数参数传递来避免陷阱。 | 可以直接在闭包中安全地引用循环变量，代码更简洁。 |

**结论：**
Golang 不同版本之间关于闭包参数传递最核心的差异在于 **Go 1.22 对 `for` 循环变量语义的根本性改变**。在此之前，开发者需要时刻警惕循环变量共享带来的问题；在此之后，这种常见的编程错误得到了语言层面的解决，使得代码更加健壮和直观。对于维护旧项目或与旧版本协作的开发者来说，理解这一差异至关重要。

### 补充
1.22版本之后，for range 语句新增支持了对整数类型进行迭代